!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.WoodenLadder=e():t.WoodenLadder=e()}(this,function(){return function(t){function e(i){if(o[i])return o[i].exports;var n=o[i]={exports:{},id:i,loaded:!1};return t[i].call(n.exports,n,n.exports,e),n.loaded=!0,n.exports}var o={};return e.m=t,e.c=o,e.p="",e(0)}([function(t,e,o){"use strict";t.exports=o(1)},function(t,e){/**
	 * @author Piotr Kowalski <piecioshka@gmail.com> (http://piecioshka.pl/)
	 * @name wooden-ladder
	 * @description Invokes 'fn1' until 'limit' is reached after that call 'fn2'
	 * @version 1.1.1
	 * @license MIT
	 * @example
	 * let WoodenLadder = require('wooden-ladder');
	 *
	 * let fn1 = () => console.log(1);
	 * let fn2 = () => console.log(2);
	 * let lad = new WoodenLadder(3, fn1, fn2);
	 *
	 * lad.climb(); // fired "fn1"
	 * lad.climb(); // fired "fn1"
	 * lad.climb(); // fired "fn1"
	 *
	 * lad.climb(); // fired "fn2"
	 * lad.climb(); // fired "fn2"
	 * lad.climb(); // fired "fn2"
	 * ...
	 * lad.climb(); // fired "fn2"
	 */
"use strict";function o(t,e,o){this.step=0,this.limit=t,this.fn1=e,this.fn2=o}o.prototype={climb:function(){this.step<this.limit?(this.step++,this.fn1()):this.fn2()},reset:function(){this.step=0}},t.exports=o}])});
//# sourceMappingURL=wooden-ladder.min.js.map